package semantic

import (
	"fmt"
	"log"

	"github.com/jpr98/compis/constants"
	"github.com/jpr98/compis/parser"
	"github.com/jpr98/compis/utils"
)

// Our Listener that extends proyecto_listener interface generated by antlr
type MyListener struct {
	*parser.BaseProyectoListener
	scopeStack      utils.StringStack
	currentFunction string
	//TODO: store type of function (create FunctionAttributes?)
	functionTable       FunctionTable
	unassignedVariables []string
}

func NewListener() MyListener {
	var listener MyListener
	listener.scopeStack = utils.StringStack{}
	listener.currentFunction = ""
	listener.functionTable = make(map[string]*FunctionTableContent)
	listener.unassignedVariables = make([]string, 0)
	return listener
}

func (l *MyListener) GetFunctionTable() map[string]*FunctionTableContent {
	return l.functionTable
}

// Validates uniqueness of the function ID defined by the developer
func (l *MyListener) handleFunctionRedefinition(scope string) {
	if function, exists := l.functionTable[l.currentFunction]; exists {
		if function.Scope == scope {
			log.Fatal(l.currentFunction + " is already Defined in scope " + l.scopeStack.Top())
		}
	}
}

// Adds function ID to the functionTable
func (l *MyListener) addToFunctionTable(typeOf string, scope string) {
	l.handleFunctionRedefinition(scope)
	l.functionTable[l.currentFunction] = &FunctionTableContent{}
	l.functionTable[l.currentFunction].Vars = make(map[string]*VariableAttributes)
	l.functionTable[l.currentFunction].TypeOf = typeOf
	l.functionTable[l.currentFunction].Scope = scope
}

func (l *MyListener) EnterProgram(c *parser.ProgramContext) {
	l.currentFunction = c.ID().GetText()
	l.addToFunctionTable("void", "")
	l.scopeStack.Push(c.ID().GetText())
}

func (l *MyListener) EnterClassDef(c *parser.ClassDefContext) {
	l.currentFunction = c.ID(0).GetText()
	l.addToFunctionTable("void", l.scopeStack.Top())
	l.scopeStack.Push(c.ID(0).GetText())
}

// After defining the classes, we need to continue addressing variables to the program function.
func (l *MyListener) ExitClassDef(c *parser.ClassDefContext) {
	l.scopeStack.Pop()
	l.currentFunction = l.scopeStack.Top()
}

func (l *MyListener) EnterFunctions(c *parser.FunctionsContext) {
	l.currentFunction = c.ID().GetText()
	var typeString string
	if c.TypeRule() != nil {
		typeString = c.TypeRule().GetText()
	} else if c.VOID() != nil {
		typeString = c.VOID().GetText()
	}

	l.addToFunctionTable(typeString, l.scopeStack.Top())
}

func (l *MyListener) EnterMain(c *parser.MainContext) {
	l.currentFunction = c.MAIN().GetText()
	l.addToFunctionTable("void", l.scopeStack.Top())
}

func (l *MyListener) EnterVarsDec(c *parser.VarsDecContext) {
	id := c.ID().GetText()
	l.unassignedVariables = append(l.unassignedVariables, id)
}

func (l *MyListener) EnterParameter(c *parser.ParameterContext) {
	id := c.ID().GetText()
	l.unassignedVariables = append(l.unassignedVariables, id)
}

func (l *MyListener) EnterTypeRule(c *parser.TypeRuleContext) {

	for _, id := range l.unassignedVariables {
		l.validateVariableInScope(id)
		currVariable := VariableAttributes{id, c.GetText()}
		l.functionTable[l.currentFunction].Vars[id] = &currVariable
	}
	l.unassignedVariables = nil
}

func (l *MyListener) EnterForLoop2(c *parser.ForLoop2Context) {
	id := c.ID().GetText()
	currVariable := VariableAttributes{id, constants.TYPEINT.String()}
	l.functionTable[l.currentFunction].Vars[id] = &currVariable
}

func (l *MyListener) ExitProgram(c *parser.ProgramContext) {
	l.scopeStack.Pop()
	l.printFunctions()
}

//Debugger Helpers
func (l *MyListener) printFunctions() {
	for fname, function := range l.functionTable {
		fmt.Printf("\n *Function: %s Returns: %s Scope: %s\n", fname, function.TypeOf, function.Scope)
		for id, variable := range function.Vars {
			fmt.Printf("%s: %s \n", id, variable.TypeOf)
		}
	}
}

func (l *MyListener) validateVariableInScope(id string) {
	if _, exists := l.functionTable[l.currentFunction].Vars[id]; exists {
		log.Fatal(id + " is already Defined")
	}
}
