package semantic

import (
	"fmt"
	"log"

	"github.com/jpr98/compis/parser"
)

// TODO: Store initialized variables value?

type scopeStack struct {
	stack []string
}

func (ss *scopeStack) currentScope() string {
	return ss.stack[len(ss.stack)-1]
}

func (ss *scopeStack) push(scope string) {
	ss.stack = append(ss.stack, scope)
}

func (ss *scopeStack) pop() {
	ss.stack = ss.stack[:len(ss.stack)-1]
}

// Stores all attributes of the variables
type VariableAttributes struct {
	name   string
	typeOf string
}

type FunctionTableContent struct {
	typeOf string
	vars   map[string]*VariableAttributes
	scope  string
}

// Our Listener that extends proyecto_listener interface generated by antlr
type MyListener struct {
	*parser.BaseProyectoListener
	scopeStack      scopeStack
	currentFunction string
	//TODO: store type of function (create FunctionAttributes?)
	functionTable       map[string]*FunctionTableContent
	unassignedVariables []string
}

func NewListener() MyListener {
	var listener MyListener
	listener.scopeStack = scopeStack{}
	listener.currentFunction = ""
	listener.functionTable = make(map[string]*FunctionTableContent)
	listener.unassignedVariables = make([]string, 0)
	return listener
}

// Validates uniqueness of the function ID defined by the developer
func (l *MyListener) handleFunctionRedefinition(scope string) {
	if function, exists := l.functionTable[l.currentFunction]; exists {
		if function.scope == scope {
			log.Fatal(l.currentFunction + " is already Defined in scope " + l.scopeStack.currentScope())
		}
	}
}

// Adds function ID to the functionTable
func (l *MyListener) addToFunctionTable(typeOf string, scope string) {
	l.handleFunctionRedefinition(scope)
	l.functionTable[l.currentFunction] = &FunctionTableContent{}
	l.functionTable[l.currentFunction].vars = make(map[string]*VariableAttributes)
	l.functionTable[l.currentFunction].typeOf = typeOf
	l.functionTable[l.currentFunction].scope = scope
}

func (l *MyListener) EnterProgram(c *parser.ProgramContext) {
	l.currentFunction = c.ID().GetText()
	l.addToFunctionTable("void", "")
	l.scopeStack.push(c.ID().GetText())
}

func (l *MyListener) EnterClassDef(c *parser.ClassDefContext) {
	l.currentFunction = c.ID(0).GetText()
	l.addToFunctionTable("void", l.scopeStack.currentScope())
	l.scopeStack.push(c.ID(0).GetText())
}

// After defining the classes, we need to continue addressing variables to the program function.
func (l *MyListener) ExitClassDef(c *parser.ClassDefContext) {
	l.scopeStack.pop()
	l.currentFunction = l.scopeStack.currentScope()
}

func (l *MyListener) EnterFunctions(c *parser.FunctionsContext) {
	l.currentFunction = c.ID().GetText()
	var typeString string
	if c.TypeRule() != nil {
		typeString = c.TypeRule().GetText()
	} else if c.VOID() != nil {
		typeString = c.VOID().GetText()
	}

	l.addToFunctionTable(typeString, l.scopeStack.currentScope())
}

func (l *MyListener) EnterMain(c *parser.MainContext) {
	l.currentFunction = c.MAIN().GetText()
	l.addToFunctionTable("void", l.scopeStack.currentScope())
}

func (l *MyListener) EnterVarsDec(c *parser.VarsDecContext) {
	id := c.ID().GetText()
	l.unassignedVariables = append(l.unassignedVariables, id)
}

func (l *MyListener) EnterParameter(c *parser.ParameterContext) {
	id := c.ID().GetText()
	l.unassignedVariables = append(l.unassignedVariables, id)
}

func (l *MyListener) EnterTypeRule(c *parser.TypeRuleContext) {

	for _, id := range l.unassignedVariables {
		l.validateVariableInScope(id)
		currVariable := VariableAttributes{id, c.GetText()}
		l.functionTable[l.currentFunction].vars[id] = &currVariable
	}
	l.unassignedVariables = nil
}

//Debugger Helpers

func (l *MyListener) ExitProgram(c *parser.ProgramContext) {
	l.scopeStack.pop()
	//l.printFunctions()
}

func (l *MyListener) printFunctions() {
	for fname, function := range l.functionTable {
		fmt.Printf("\n *Function: %s Returns: %s Scope: %s\n", fname, function.typeOf, function.scope)
		for id, variable := range function.vars {
			fmt.Printf("%s: %s \n", id, variable.typeOf)
		}
	}
}

func (l *MyListener) validateVariableInScope(id string) {
	if _, exists := l.functionTable[l.currentFunction].vars[id]; exists {
		log.Fatal(id + " is already Defined")
	}
}
