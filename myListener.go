package main

import (
	"fmt"
	"log"
	"github.com/jpr98/compis/parser"
)


// TODO: Store initialized variables value?

// TODO: Handle redefinition of variables

// Stores all attributes of the variables
type VariableAttributes struct {
	name string
	typeOf string
}

// Our Listener that extends proyecto_listener interface generated by antlr
type MyListener struct {
	*parser.BaseProyectoListener
	currentFunction string
	//TODO: store type of function (create FunctionAttributes?)
	functionTable map[string] map[string]*VariableAttributes
	unassignedVariables []string
	programId string
}

func NewListener() MyListener {
	var listener MyListener
	listener.currentFunction = ""
	listener.programId = ""
	listener.functionTable = make(map[string] map[string]*VariableAttributes)
	listener.unassignedVariables = make([]string,0)
	return listener
}

// Validates uniqueness of the function ID defined by the developer
func (l *MyListener) handleFunctionRedefinition() {
	if _, exists := l.functionTable[l.currentFunction]; exists {
		log.Fatal(l.currentFunction + " is already Defined")
	}
}

// Adds function ID to the functionTable
func (l *MyListener) addToFunctionTable() {
	l.handleFunctionRedefinition()
	l.functionTable[l.currentFunction] = make(map[string]*VariableAttributes)
}

func (l *MyListener) EnterProgram(c *parser.ProgramContext) {
	l.programId = c.ID().GetText()
	l.currentFunction = l.programId
	l.addToFunctionTable()
}

func (l *MyListener) EnterClassDef(c *parser.ClassDefContext) {
	l.currentFunction = c.ID(0).GetText()
	l.addToFunctionTable()
}

// After defining the classes, we need to continue addressing variables to the program function.
func (l *MyListener) ExitClassDef(c *parser.ClassDefContext) {
	l.currentFunction = l.programId
}

func (l *MyListener) EnterFunctions(c *parser.FunctionsContext) {
	l.currentFunction = c.ID().GetText()
	l.addToFunctionTable()
}

func (l *MyListener) EnterMain(c *parser.MainContext) {
	l.currentFunction = c.MAIN().GetText()
	l.addToFunctionTable()
}

func (l *MyListener) EnterVarsDec(c *parser.VarsDecContext){
	id := c.ID().GetText()
	l.unassignedVariables = append(l.unassignedVariables,id)
}

func (l *MyListener) EnterParameter(c *parser.ParameterContext){
	id := c.ID().GetText()
	l.unassignedVariables = append(l.unassignedVariables,id)
}

func (l *MyListener) EnterTypeRule (c *parser.TypeRuleContext){

	for _, id := range l.unassignedVariables {
		currVariable := VariableAttributes{id,c.GetText()}
		l.functionTable[l.currentFunction][id] = &currVariable
	}
	l.unassignedVariables = nil
}

//Debugger Helpers

func (l *MyListener) ExitProgram(c *parser.ProgramContext) {
	l.printFunctions()
}

func (l *MyListener) printFunctions(){
	for fname, variableTable := range l.functionTable { 
		fmt.Printf("\n *Function: %s \n", fname)
		for id, t := range variableTable {
			fmt.Printf("%s: %s \n", id, t)
		}
	}
}


