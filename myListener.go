package main

import (
	"fmt"
	"log"

	"github.com/jpr98/compis/parser"
)

// TODO: Store initialized variables value?

// Stores all attributes of the variables
type VariableAttributes struct {
	name   string
	typeOf string
}

type FunctionTableContent struct {
	typeOf string
	vars   map[string]*VariableAttributes
	scope  string
}

// Our Listener that extends proyecto_listener interface generated by antlr
type MyListener struct {
	*parser.BaseProyectoListener
	scopeStack      []string
	currentFunction string
	//TODO: store type of function (create FunctionAttributes?)
	functionTable       map[string]*FunctionTableContent
	unassignedVariables []string
	programId           string
}

func NewListener() MyListener {
	var listener MyListener
	listener.scopeStack = make([]string, 1)
	listener.currentFunction = ""
	listener.functionTable = make(map[string]*FunctionTableContent)
	listener.unassignedVariables = make([]string, 0)
	return listener
}

// Validates uniqueness of the function ID defined by the developer
func (l *MyListener) handleFunctionRedefinition(scope string) {
	if function, exists := l.functionTable[l.currentFunction]; exists {
		if function.scope == scope {
			log.Fatal(l.currentFunction + " is already Defined")
		}
	}
}

// Adds function ID to the functionTable
func (l *MyListener) addToFunctionTable(typeOf string, scope string) {
	l.handleFunctionRedefinition(scope)
	l.functionTable[l.currentFunction] = &FunctionTableContent{}
	l.functionTable[l.currentFunction].vars = make(map[string]*VariableAttributes)
	l.functionTable[l.currentFunction].typeOf = typeOf
	l.functionTable[l.currentFunction].scope = scope
}

func (l *MyListener) EnterProgram(c *parser.ProgramContext) {
	l.programId = c.ID().GetText()
	l.currentFunction = l.programId
	l.scopeStack = append(l.scopeStack, c.ID().GetText())
	l.addToFunctionTable("void", "")
}

func (l *MyListener) EnterClassDef(c *parser.ClassDefContext) {
	l.currentFunction = c.ID(0).GetText()
	l.scopeStack = append(l.scopeStack, c.ID(0).GetText())
	l.addToFunctionTable("void", l.programId)
}

// After defining the classes, we need to continue addressing variables to the program function.
func (l *MyListener) ExitClassDef(c *parser.ClassDefContext) {
	l.currentFunction = l.programId
	l.scopeStack = l.scopeStack[:len(l.scopeStack)-1]
}

func (l *MyListener) EnterFunctions(c *parser.FunctionsContext) {
	l.currentFunction = c.ID().GetText()
	var typeString string
	if c.TypeRule() != nil {
		typeString = c.TypeRule().GetText()
	} else if c.VOID() != nil {
		typeString = c.VOID().GetText()
	}

	l.addToFunctionTable(typeString, l.scopeStack[len(l.scopeStack)-1])
}

func (l *MyListener) EnterMain(c *parser.MainContext) {
	l.currentFunction = c.MAIN().GetText()
	l.addToFunctionTable("void", l.scopeStack[len(l.scopeStack)-1])
}

func (l *MyListener) EnterVarsDec(c *parser.VarsDecContext) {
	id := c.ID().GetText()
	l.unassignedVariables = append(l.unassignedVariables, id)
}

func (l *MyListener) EnterParameter(c *parser.ParameterContext) {
	id := c.ID().GetText()
	l.unassignedVariables = append(l.unassignedVariables, id)
}

func (l *MyListener) EnterTypeRule(c *parser.TypeRuleContext) {

	for _, id := range l.unassignedVariables {
		l.validateVariableInScope(id)
		currVariable := VariableAttributes{id, c.GetText()}
		l.functionTable[l.currentFunction].vars[id] = &currVariable
	}
	l.unassignedVariables = nil
}

//Debugger Helpers

func (l *MyListener) ExitProgram(c *parser.ProgramContext) {
	l.scopeStack = l.scopeStack[:len(l.scopeStack)-1]
	l.printFunctions()
}

func (l *MyListener) printFunctions() {
	for fname, function := range l.functionTable {
		fmt.Printf("\n *Function: %s Returns: %s Scope: %s\n", fname, function.typeOf, function.scope)
		for id, variable := range function.vars {
			fmt.Printf("%s: %s \n", id, variable.typeOf)
		}
	}
}

func (l *MyListener) validateVariableInScope(id string) {
	if _, exists := l.functionTable[l.currentFunction].vars[id]; exists {
		log.Fatal(id + " is already Defined")
	}
}

/*
{
	function: {
		type: "",
		vars: {
			a: {
				type: "",
				-
			}
		}
	},

	function: {
		type: "",
		vars: {
			a: {
				type: "",
				-
			}
		}
	}

}

{
	global: {
			main: {
			type: "void",
			vars: {
				a: {
					type: "",
					-
				}
			}
		}
	},

	Car: {

	},

	Boat: {

	}

}

*/
